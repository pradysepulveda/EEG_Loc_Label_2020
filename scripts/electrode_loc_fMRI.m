
function [label_matrix]= electrode_loc_fMRI(surface_info, electrodes_info, n_electrodes)
% Localization of potential electrodes

% surface_info: struct with head mask matrix info from Brainstorm.
% electrodes_info: path to the text file containing default electrode
% info.(e.g. test.xyz)
% n_electrodes: number of electrodes to be labelled (in this case 64).

% Se requiere tener acceso a la segmentaciones y reconstrucciones hechas por
% Freesurfer y luego cargadas utilizando Brainstorm. 
% Desde Brainstorm se deben cargar las variables de la superficie de la
% cabeza hacia el workspace de MATLAB
% carga datos desde la matriz con informacion de superficie

% It is required to have access to the surface
% reconstructions generated by Freesurfer or Brainstorm. The structure with
% head model information can be exported from Brainstorm to Matlab
% workspace (surface_info).

%Access to segmentation and reconstruction done by Freesurfer needed. Load
%head surface files using brainstorm (you should send it to MATLAB
%workspace)

% P Sepulveda -- 2019

face = surface_info.Faces;
nodes = surface_info.Vertices;
curvature=surface_info.Curvature;

% Define electrodes matrix

position = zeros(n_electrodes,3);

% Load XYZ electrode file

a = fopen(electrodes_info);
b = textscan(a, '%f %f %f %f %s', 'delimiter', ' ', 'CollectOutput',true);

position = zeros(64,3);
for n=1:length(position);
    position(n,:) = b{1,1}(n,2:4);
end


figure
patch('faces',face,'vertices',nodes,'CData',curvature,'EdgeColor','interp');
hold on;
plot3(position(:,1),position(:,2),position(:,3),'.b','LineWidth',30,'MarkerSize',50);
hold off;
axis off;
daspect([1 1 1]);
cameramenu;
drawnow


%Ordenamiento de los nodos de la superficie de acuerdo a la informaci?n de
%curvatura
%Sort the nodes on the surface according to curvature information

[Y,I]=sort(curvature,1,'descend');

node_sort=nodes(I,:);

% Se eliminan los nodos bajo la coordenada 0 0 0 para evitar problemas con
% la nariz y cuello
% Delete nodes under certain coordinate to avoid problems with nose and
% neck

node_brain=[0 0 0];
count=1;
for i=1:length(node_sort)
    if node_sort(i,3)>0
        node_brain(count,:)=node_sort(i,:);
        count=count+1;
    end
end

% Seleccionar el numero de nodos con mayor curvatura a considerar para la ubicaci?n de electrodos
% Select the number of nodes with highes curvature to consider the location
% of the electrodes

num_tops=2000;

% Figura con nodos seleccionados
% Plot figure with the selected top nodes
figure
patch('faces',face,'vertices',nodes,'CData',curvature,'EdgeColor','interp');
hold on;
plot3(node_brain(1:num_tops,1),node_brain(1:num_tops,2),node_brain(1:num_tops,3),'.r','LineWidth',10000, 'MarkerSize',25);
daspect([1 1 1]);
axis off;

% Determinacion de umbral desde datos empiricos (distancia entre puntos
% extremos de un electrodo)
% I selected a threshold to identify the points as belonging to the same electrode 
% using data from one subject (may be necessary to change this for different subjects?)

y= [-0.09904,-0.02536,0.05185;
    -0.09853,-0.02972,0.04493];
tresh=pdist(y,'euclidean');

% COMMENT PSD JAN/2019
% In the original WE FIXED IT TO A VALUE OF  tresh = 0.0082 for diameter of
% the electrode. I asssume this should be around 1 cm considering the size
% of electrodes I calculated.

%%%Asignar puntos a un label: se incluir?n elementos mas cercanos que el
%%%threshold determinado
% Assign points (vertices) to one label: vertices closer than the selected
% threshold will be assumed to belong to the same electrode

node_slc=[node_brain(1:num_tops,:)];
label_number=1; 
resta_elem=0;
label_selec=cell(1,1);
label_mark=zeros(1,length(node_slc));

% Going over all the points selected with maximum curvature 
for i=1:num_tops
    ii=1;
    
    % if the point does not have a label add a new one
    if label_mark(i)==0;
        label_selec{label_number,ii}=node_slc(i,:); %init label group
        label_mark(i)=label_number;
        ii=ii+1;
    else
        continue;
    end
    
    for j=i:num_tops
        if label_mark(j)==0;
            d_aux= [node_slc(i,:);
                          node_slc(j,:)];
            d_aux1=pdist(d_aux,'euclidean');
            if d_aux1<tresh && d_aux1~=0
                label_selec{label_number,ii}=node_slc(j,:);
                label_mark(j)=label_number;
                ii=ii+1;
            end
        end
    end
    label_number=label_number+1;
end



% Show sample of 4 electrodes clusters

%clustr1 = vertcat(label_selec{1,:});
%clustr2 = vertcat(label_selec{2,:});
%clustr3 = vertcat(label_selec{3,:});
%clustr4 = vertcat(label_selec{4,:});

%
clustr=cell(1,1);
for j = 1:round(length(label_selec)/3)
clustr{j} = vertcat(label_selec{j,:});
end


% Generate random colors
cmap1 = hsv(length(clustr))
cmap2 = lines(length(clustr)) 
% Combine them into one tall colormap.
combinedColorMap = [cmap1; cmap2]
% Pick n rows at random.
randomRows = randi(size(combinedColorMap, 1), [length(clustr), 1])
% Extract the rows from the combined color map.
randomColors = combinedColorMap(randomRows, :)

figure
patch('faces',face,'vertices',nodes,'CData',curvature,'EdgeColor','interp');
for j = 1:length(randomColors)
hold on;
scatter3(clustr{j}(:,1),clustr{j}(:,2),clustr{j}(:,3), 'filled','MarkerFaceColor',randomColors(j,:));
end
daspect([1 1 1]);
axis off
set(gcf,'color','black')

% Crear matriz con las posiciones promedio de los elementos para los labels
% con m?s de diez elementos
% Create matrix with al the label position (mean positions of all the
% elements within that label) for the labels with more than 10 elements
% (points)

for i1=1:length(label_selec(:,1))
   elem_disp=length(find(~cellfun(@isempty,label_selec(i1,:))));
    if  elem_disp>10
        elem_disp_cord_x=zeros(1,elem_disp);
        elem_disp_cord_y=zeros(1,elem_disp);
        elem_disp_cord_z=zeros(1,elem_disp);
        for ii1=1:elem_disp
            elem_disp_cord_x(ii1)=label_selec{i1,ii1}(1);
            elem_disp_cord_y(ii1)=label_selec{i1,ii1}(2);
            elem_disp_cord_z(ii1)=label_selec{i1,ii1}(3);
        end
        label_prom{i1} = [mean( elem_disp_cord_x) mean( elem_disp_cord_y) mean( elem_disp_cord_z) ];
       
    end
end

label_matrix=[];
for j=1:length(label_prom)
    label_matrix=[label_matrix 
                        label_prom{j}];
end





% Mostrar volumen con los electrodos correctamente ubicados
% Show head volume with the identified vertices (hopefully the right
% electrodes)

figure
patch('faces',face,'vertices',nodes,'CData',curvature,'EdgeColor','interp','FaceAlpha',.1);
hold on;
plot3(label_matrix(:,1),label_matrix(:,2),label_matrix(:,3),'.r','LineWidth',15000,'MarkerSize',100);
daspect([1 1 1]);
%axis off;







  